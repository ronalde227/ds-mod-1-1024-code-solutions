# -*- coding: utf-8 -*-
"""time-series-project.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1vmZpdR0MYscD8Y_EtdwYgS4XpIDDX0Rn
"""

#pip install yahoo finance
#import yfinance as yf
#retrieve stock price
#use open or close data
#analyze time series - check for stationary - if not make it stationary
#check for seasonality acf or pacf
#you can also use decompose
#figure out the best values of pdq and or season pdq.
#6. predit price maybe two time time stamp.
#collect 1 year of data at one hour increment
#minimize the test rmse, base off the final 50 records
#pdq values have been given so you can use grid search.
# 27 gridsearch
#save timestamp, predicction, and actual price to a database using sql

import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
import yfinance as yf

ticker = 'AAPL'

end_date = pd.to_datetime('today')
start_date = end_date - pd.DateOffset(years=1)

data = yf.download(ticker, start=start_date, end=end_date , interval='1h')

data.index = pd.to_datetime(data.index)

data.index = pd.to_datetime(data.index)

data.sort_index(inplace=True)

data.info()

close = data['Close']
full_close = close

close

#imputing time series with forward fill or backwords fill
close = close.fillna(method='ffill')
close.isna().sum()

close.index = pd.to_datetime(close.index)

close

#last 50 records of close will be stored in test
test = close[-50:]
close = close[:-50]

close.index = pd.to_datetime(close.index)

len(test)

#setting date to index

close.plot()

# The data is postive almost exponetial trend
# there is a lot of variance as well
close_log = np.log(close)
close_log.plot()

close_diff1 = close.diff()

close_diff1.plot()

close_log_diff1 = close_log.diff()

close_log_diff1.plot()

from statsmodels.graphics.tsaplots import plot_acf, plot_pacf
from sklearn.metrics import root_mean_squared_error
from logging import root
from statsmodels.tsa.stattools import acf, pacf
from statsmodels.tsa.arima.model import ARIMA

plot_acf(close_diff1.dropna(), lags = np.arange(1,100));
plt.ylim(-0.3,.3)
#ACF does not indicate any seasonality use ARIMA instead of SARIMAX

plot_pacf(close_diff1.dropna(), lags = np.arange(1,100));
plt.ylim(-0.2,.2)

#we want to find the best combination of p, d, q
p_vals = [0,1,2]
d_vals = [1]
q_vals = [0,1,2,3]

import itertools

best_rmse  = np.inf
best_pdq = (0,0,0)
best_model=None

for pdq in itertools.product(p_vals, d_vals, q_vals):
  model = ARIMA(close, order=pdq).fit()
  fv = model.fittedvalues
  rmse = root_mean_squared_error(close, fv)
  if rmse < best_rmse:
    best_rmse = rmse
    best_pdq = pdq
    best_model = model

print(best_rmse)
print(best_pdq)

close[1:].plot()
best_model.fittedvalues[1:].plot()

best_model.fittedvalues.plot()

close.plot()
best_model.fittedvalues.plot()
best_model.forecast(50).plot()

best_model.forecast(100).plot()

test.plot()
plt.plot(test.index, best_model.forecast(50).values)

